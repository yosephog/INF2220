


import java.util.ArrayList;


public class BinaryTree {
     Node root;
    long totalTime=0; // total time elapsed during similar check
    int nodeCounter=0; // total node counter
    
   public class Node {
        Node left;
        Node right;
        String data;
        public Node(String data){
            this.data=data;
        }
    }
   // this method gets the first and last node for the stastic
   public void firstAndLast(){
       Node current=root; // for checking the left side of the tree
       Node temp=root;  // for checking the right side of the tree
       String last="";
       String first="";
       while(current != null){
           last=current.data;
           current=current.right;
       }
        while(temp != null){
           first=temp.data;
           temp=temp.left;
       }
       System.out.println("the first word is " + first);
       System.out.println("the last word is " + last);
   }
   
   // this method insert String data accourding to Binary tree method
    public void insert(String data){
        Node ny=new Node(data);
        // the first string becomes the root
        if(root==null){
            root=ny;
            nodeCounter++;
        }
        else{
            Node current=root;
            Node parent;
            while(true){
                parent=current;
                if(current.data.compareTo(data) > 0){
                    current=current.left;
                    if(current==null){
                        parent.left=ny;
                        nodeCounter++;
                        return;
                    }
                }
                else{
                    current=current.right;
                    if(current==null){
                        parent.right=ny;
                        nodeCounter++;
                        return;
                    }
                }
            }
        }
    }
    // a method for printing out the inserted words
   
    public void print(Node curr){
        if(curr != null){
            
            print(curr.left);
            System.out.println(curr.data);
            print(curr.right);
           
        }
    }
    
    // this method find the word and return a string. if it isn't found
    // returns null
    public String find(String dat){
        Node current=root;
         // as long as the word isn't found 
        while(current != null && current.data.compareTo(dat)!=0){
            if(current.data.compareTo(dat)>0){
                current=current.left;
                
            }
            else
                current=current.right;
        }
       if (current !=null)
           return current.data;
       else
           return null;
    }
    /**
     this method gets all the similar word given in the parameter.
     it also calculate the time it takes to get all the similar words
     */
    public void similarWord(String dat){
        
       long  start=System.currentTimeMillis();
       
       // generating all the similar words by calling the string finder class
        StringFinder st=new StringFinder();
        st.similarOne(dat);
        st.similarTwo(dat);
        st.similarThree(dat);
        st.similarFour(dat);
        
        // this list have all the similar words generated by the stringFinder
        //class
       ArrayList<String> wordList=st.allSimilarList();
       ArrayList<String> similar=new ArrayList<>();
       
       
           for(String s:wordList){
                String word=find(s);
               
                if(word!=null)
               similar.add(word);
           }
           // if the word isn't found display the similar words
          if(!similar.isEmpty()){
              System.out.println("the word you are looking for is not found.");
              System.out.println("list of similar words are ");
              for(String si:similar)
              System.out.println(si);
          }
          if(similar.isEmpty())
              System.out.println("There is no similar word either");
          
      long end=System.currentTimeMillis();
      this.totalTime=this.totalTime+(end - start);
       
    }
    public long getTimeEllapsed(){
        return this.totalTime;
    }
    public int getDepth(Node current){
      int leftc=0;
      int rightc=0;
      if(current !=null){
          leftc=getDepth(current.left) + 1;
          rightc=getDepth(current.right) + 1;
      }
     
      
      if(leftc > rightc)
          return leftc;
      else 
          return rightc;
      
          
  }
    // this method calculate the number of nodes per level
    public int nodesPerLevel(Node current,int index){
      int x=0;
      if (current == null)
          return 0;
      if(index==1)
          return 1;
           x= nodesPerLevel(current.left,index-1) +
                  nodesPerLevel(current.right,index-1);
      return x;
  }
    public void printNodesPerLevelAndAverage(){
       Node current=root;
      int depthTree=getDepth(current);
      ArrayList<Integer> list=new ArrayList<>();
      
      // add all the nodes per level until the depth of three is riched
       for(int i=1;i<depthTree+1;i++){
           list.add(nodesPerLevel(current, i));
            
       }
         int depth=0;
         int level=0;
         
         int totalDepth=0;
         // prints out all the number of nodes per level and 
         //calculate the total depth
          for(int ll:list){
               System.out.println("nr of Nodes at level " + level + " is " + ll);
               totalDepth=totalDepth + (depth * ll);
               depth++;
               level++;
               
          }
          int average=totalDepth/nodeCounter;
          System.out.println("the average depth is " + average);
             
    }
   
}
